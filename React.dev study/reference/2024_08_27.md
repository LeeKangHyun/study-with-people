# use
- Promise, context와 같은 리소스의 값을 읽을 수 있다.
- Component, Hook이어야 한다.
- Suspense, Error Boundary와 함께 동작
- hook과 다른 점 : 조건문(if)와도 쓸 수 있어요.
- use(recource) : resource에 Promise와 함께 쓴다면, Suspense와 Error Boundary를 티리거 해요
- 서버컴포넌트에서는 use보다는 async-await을 사용하세요. use는 Promise가 resolved 되면 리렌더링이 일어나요.
- 서버컴포넌트에서 Promise를 생성해서, 클라이언트 컴포넌트에 전달하는 방식으로 사용하세요. 클라이언트 컴포넌트에서 Promise를 생성하면 매 렌더마다 Promise를 생성하기 때문이에요. (하지만 use는 클라이언트 컴포넌트에서 쓰자. 예시코드 [streaming-data-from-server-to-client](https://react.dev/reference/react/use#streaming-data-from-server-to-client))
- use(ThemeContext): useContext(SomeContext)와 같은 결과인듯
- 훅과 다르게 loop나 조건부 안에서 사용이 가능 
- 서버 컴포넌트에서 클라이언트 컴포넌트로 promise 를 전달하는 것을 선호. 클라이언트 컴포넌트 promise 는 렌더링할때마다 다시 생성되서 
- use는 try-catch 블록 안에서 호출할 수 없고, 에러바운더리로 래핑해서 사용하거나 promise .catch 사용
- 서버컴포넌트에서 Promoise를 await 하면, 렌더링이 블로킹돼요
- 꼮 hook 아니면 component 안에서 use를 호출하자
- 기존 훅과 다르게 조건문 안에서도 사용 가능하다. 
- suspense, error-boundary를 같이 사용하면서 에러나 비동기 상태를 쉽게 관리 할 수 있다.
- use(context)는 컴포넌트 바깥에 위치한 컨텍스트중 가장 가까운 걸 찾아서 참고한다.(pitfall에 있는 내용)
- 서버 컴포넌트에서 클라이언트 컴포넌트로 Promise를 전달하면 Promise가 서버 컴포넌트의 렌더링을 차단하는 것을 방지할 수 있다. (await과 다른점)
